
## 什么是redis
 redis是一个开源的高性能KV非关系型数据库，支持存储value相对较多
## redis优点
- 读写性能好
- 支持数据持久化 AOF和RDB
- 支持事务，所有操作都是原子性要么全部成功，要么全部失败
- 数据结构丰富
- 支持主从赋值，可以进行读写分离
- 丰富的特新，可以用于缓存，设置key的过期时间，过期后会自动删除

## 为什么要用缓存
- 高性能：每个请求都访问数据库的话会有大量的IO操作，IO相对于内存的读写效率慢的多
- 高并发：大并发情况下如果都用IO查询，会造成数据库压力剧增，使用缓存可以减少直接访问库的压力
## 为什么使用redis，而不是用本地缓存
- map和guava使用的都是本地缓存，生命周期跟随JVM的活动来生存，与进程共用内存，每个进程各自保存一份，占用空间多，还有可能由各个进行数据不一致的情况
- 使用redis等分布式缓存框架，所有服务公用一份缓存数据，数据有一致性，并且redis可以保证高可用。
## redis为什么那么快
- 完全基于内存，绝大部分都是内存操作
- 数据结构简单
- 采用单线程，避免了线程的上下文切换，不用考虑锁相关的内容
- 使用IO多路复用模型，非阻塞IO

## reids数据类型

| 数据类型   | 存储的值   | 应用场景                 |
| ------ | ------ | -------------------- |
| string | 字符串，数字 | 简单的kv存储              |
| list   | 列表     | 存储列表型数据结构，粉丝列表，评论列表等 |
| set    | 无序集合   | 交集并集差集等操作，比如公共好友等    |
| hash   | 键值对    | 结构化对象                |
| zset   | 有序集合   | 根据权重进行排名，比如某个前几名用户   |


## redis应用场景
- 计数器：利用string的自增自减运算
- 缓存：热点数据，利用淘汰策略保证缓存命中率
- 会话缓存：
- 消息队列
- 分布式锁：
	- 使用redis自带的setnx命令实现的分布式锁
	- redlock实现的分布式锁
## RDB
- 是redis默认的持久化方式，将redis中数据形成一个dump文件，
- 优点
	- 只有一个文件
	- 容灾性好
	- 回复性能高
- 缺点：
	- 数据安全型低，每隔一段时间（1分钟 10000个key被修改）才会触发持久化，容易丢失数据
	- dump文件可读性不好
## AOF
- 是将redis执行的命令写到单独的文件中，重启时会根据命令进行恢复
- rdb和aof同时开启时，redis优先使用aof进行恢复
- 优点
	- aof通过配置，每进行一次操作就会记录到文件中
	- rewrite命令可以在文件过大时，精简一些命令，仅保留最终恢复后保持一致的命令
- 缺点：
	- aof文件大，恢复效率慢
	- 重启时比rdb启动效率低

## aof和rdb对比优缺点
- aof文件更新频率高，优先使用aof进行恢复
- aof文件比rdb安全
- rdb性能比aof高

## 如何选择持久化方式
- 如果能接收分钟内的数据丢失，可以仅使用RDB持久化方式
- 建议同时使用两种持久化方式

## Redis的过期键删除策略
- 惰性删除：当访问key时，会判断是否过期，过期则进行清除。该策略对CPU友好，但是对内存不友好，如果长期不访问会占用大量的内存
- 定期删除：每隔一段时间，redis会随机扫描一定量的带有过期时间的key，然后清除其中已经过期的key。
- redis同时使用了 惰性和定期删除两种过期策略

## redis的内存淘汰策略
- `noeviction`：内存不足时，写入新数据报错
- `allkeys-lru`：内存不足时，写入新数据，会删除最近最少使用的key
- `allkeys-random`：内存不足时，写入新数据，会随机删除一个key
- `volatile-lru`：内存不足时，在设置了过期时间的key中，移除最近最少使用的key
- `volatile-random`：内存不足时，在设置了过期时间的key中，随机删除一个
- `volatile-ttl`：内存不足时，在设置了过期时间的key中，删除快要过期的key

## redis内存达到上限
- redis写命令会报错（根据配置），读命令正常
- 或者配置内存淘汰机制，当redis内存达到上限时，冲刷调旧内容


## redis单线程
> redis核心命令处理逻辑是单线程的（**执行客户端请求，操作内存数据等**）

- 避免锁竞争
- 原子性保证，单线程串行执行，天然具备原子性
- 性能优化：有效利用CPU缓存，减少上下文开销
### 多线程场景
- 后台持久化
	- 生产RDB/AOF利用fork子进程完成
	- AOF重写，利用子进程进行
- 异步删除
- 网络IO多线程
	- 仅限于网络数据读写
### 总结
- 核心命令的执行是单线程
- 多线程辅助：通过后台处理持久化、异步删除以及多线程IO优化网络吞吐

## redis事务
> 事务是一个原子性的操作，要么全部成功，要么全部失败，
> 事务中所有的命令都序列化、按顺序执行，执行过程中不会被客户端发送的消息打断

### redis中执行事务的方式
- 事务开始：MULTI
- 添加执行命令
- 事务执行EXEC
- 执行过程中收到`exec discard watch multi`之外的命令，会把请求放到队列中排队
### redis事务相关
- reids 不支持回滚，如果一个命令在redis中失败，不进行回滚，而是继续执行余下的命令
- **如果一个事务命令出现语法错误，那么所有命令都不会执行**
- **如果一个事务出现运行错误，那么正确的命令会被执行**
- watch：乐观锁，如果监控的key发生了修改，那么之后的事务不会执行
- 基于Lua脚本，可以保证命令一次性、按顺序的执行

## redis集群
- 数据分片将数据划分为 16384个槽，分配到多个主节点
- 主从结构：每个主节点有多个从节点，实现高可用
- 通过hash的方式，将数据分片，每个节点均匀存储一定的hash槽
- 主节点宕机时，从节点自动升级为主节点
- 支持动态增删节点，槽位重新分配
- redis集群没有使用一致性hash，引入了hash槽的概念，每个key通过hash后对16834取模来决定放置到哪个槽中，集群每个节点负责一部分的hash槽
- 无法进行数据库选择，默认在0数据库中

## redis分布式
## redis分布式锁的实现
- 因为redis执行命令是单线程的，所以命令的执行就是串行的
- 利用setnx命令，如果key不存在执行命令返回1，如果key存在，不执行返回0


## 缓存穿透
- 是指大量的请求在缓存中不存在，进而请求数据库，导致数据库压力剧增
	- 解决办法是对于这种查出来的不存在的值也缓存到数据库中，过期时间设置的较小（数据量过大会影响内存）
	- 利用布隆过滤器
	- 接口限流与鉴权
## 缓存雪崩
- 大量key同时过期，导致大量请求进行数据库访问导致数据库压力剧增
	- 避免设置相同过期时间，过期时间增加随机值
	- 利用分布式锁，在加载数据时相同key只有一个线程进行数据库访问

## 布隆过滤器实现原理
“布隆过滤器是一种概率型数据结构，底层是一个二进制位数组和多个独立的哈希函数。写入数据时，将数据通过多个哈希函数映射到位数组的多个位置，并将这些位置置为 1。查询时，用同样的哈希函数计算待查数据的多个位置：

- 如果任意一个位置为 0，说明数据**一定不存在**，直接拒绝请求；
- 如果所有位置都为 1，说明数据**可能存在**​（但可能因哈希冲突误判），继续后续查询（如数据库）。  
    它的优势是空间效率极高，但存在一定的误判率，且不支持删除操作。常用于解决缓存穿透问题，快速过滤非法请求。”